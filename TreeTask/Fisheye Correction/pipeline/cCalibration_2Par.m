% Auto-generated by cameraCalibrator app on 14-Sep-2017
%-------------------------------------------------------


% Define images to process
imageFileNames = {'/Users/Clay/Desktop/Fisheye Correction/onPlane/on_plane_3.png',...
    '/Users/Clay/Desktop/Fisheye Correction/onPlane/on_plane_5.png',...
    '/Users/Clay/Desktop/Fisheye Correction/onPlane/on_plane_6.png',...
    '/Users/Clay/Desktop/Fisheye Correction/onPlane/on_plane_8.png',...
    '/Users/Clay/Desktop/Fisheye Correction/onPlane/on_plane_9.png',...
    '/Users/Clay/Desktop/Fisheye Correction/onPlane/on_plane_11.png',...
    '/Users/Clay/Desktop/Fisheye Correction/onPlane/on_plane_12.png',...
    '/Users/Clay/Desktop/Fisheye Correction/onPlane/on_plane_13.png',...
    '/Users/Clay/Desktop/Fisheye Correction/onPlane/on_plane_14.png',...
    '/Users/Clay/Desktop/Fisheye Correction/onPlane/on_plane_15.png',...
    '/Users/Clay/Desktop/Fisheye Correction/onPlane/on_plane_16.png',...
    '/Users/Clay/Desktop/Fisheye Correction/onPlane/on_plane_17.png',...
    };

% Detect checkerboards in images
[imagePoints, boardSize, imagesUsed] = detectCheckerboardPoints(imageFileNames);
imageFileNames = imageFileNames(imagesUsed);

% Generate world coordinates of the corners of the squares
squareSize = 6;  % in units of 'in'
worldPoints = generateCheckerboardPoints(boardSize, squareSize);

% Calibrate the camera
[cameraParams, imagesUsed, estimationErrors] = estimateCameraParameters(imagePoints, worldPoints, ...
    'EstimateSkew', false, 'EstimateTangentialDistortion', false, ...
    'NumRadialDistortionCoefficients', 2, 'WorldUnits', 'in', ...
    'InitialIntrinsicMatrix', [], 'InitialRadialDistortion', []);

% View reprojection errors
h1=figure; showReprojectionErrors(cameraParams, 'BarGraph');

% Visualize pattern locations
h2=figure; showExtrinsics(cameraParams, 'CameraCentric');

% Display parameter estimation errors
displayErrors(estimationErrors, cameraParams);


% For example, you can use the calibration data to remove effects of lens distortion.
originalImage = imread(imageFileNames{3});
size(originalImage)
[undistortedImage, newOrigin] = undistortImage(originalImage, cameraParams, 'OutputView', 'full');
points = detectCheckerboardPoints(imageFileNames{3});
undistortedPoints = undistortPoints(points, cameraParams);
undistortedPoints = [undistortedPoints(:,1) - newOrigin(1), ...
                    undistortedPoints(:,2) - newOrigin(2)];
                
testPoints = [50, 50; 600, 600; 800, 800; 800, 200];
testPoints2 = undistortPoints(testPoints, cameraParams);
testPoints2 = [testPoints2(:,1) - newOrigin(1), ...
                testPoints2(:,2) - newOrigin(2)];

figure(100);
subplot(1,2,1);
imshow(originalImage);
hold on;
plot(points(:,1), points(:,2), 'ro', testPoints(:,1), testPoints(:,2), 'g*');
title('Original');
hold off;

figure(100);
subplot(1,2,2);
imshow(undistortedImage);
hold on;
plot(undistortedPoints(:,1), undistortedPoints(:,2), 'ro', ...
    testPoints2(:,1), testPoints2(:,2), 'g*');
title('Undistorted');
hold off;


%Graph undistorted Checkerboards in 3D space
%depthPoints are in camera Coordinates (3D)
depthPoints = persCorrection(cameraParams, worldPoints, newOrigin, imageFileNames);

m = [0 0 0];
%check if m~=4 is necessary in following for-loops
for i = 1:size(depthPoints,3)
    if m ~= 4
        m = m + sum(depthPoints(:,:,i),1);
    end
end
zDepth = m(3) / (size(depthPoints, 1) * (size(depthPoints, 3)-1));
hold off;

%Calculate rotation of track plane by averaging x-axis and y-axis 
%rotation angles
size(depthPoints,3);
rotAngleX = zeros(1,size(depthPoints,1)*(size(depthPoints,3)-1));
rotAngleY = zeros(1,size(depthPoints,1)*(size(depthPoints,3)-1));
a = 1;
for k = 1:size(depthPoints,1)
    for h = 1:size(depthPoints,3)
        if h ~= 4
            rotAngleX(a) = abs(atan((depthPoints(k,3,h)-zDepth)/depthPoints(k,2,h)));
            rotAngleY(a) = abs(atan((depthPoints(k,3,h)-zDepth)/depthPoints(k,1,h)));
            a = a+1;
        end
    end
end

% Note: decreasing aveRot angle does not change distortion
aveRotX = mean(rotAngleX,2);
aveRotY = mean(rotAngleY,2)/5;

%Recalculate X-axis rotated points in 3d space
rotDepthPointsX = depthPoints;
rotMatX = [1 0 0; 0 cos(-aveRotX) -sin(-aveRotX); 0 sin(-aveRotX) cos(-aveRotX)];
for b = 1:size(depthPoints,1)
    for c = 1:size(depthPoints,3)
        if c ~= 4
            depthlessCoor = depthPoints(b,:,c);
            depthlessCoor(3) = depthlessCoor(3) - zDepth;
            rotDepthPointsX(b,:,c) = (rotMatX * depthlessCoor.').' + [0 0 zDepth];
        end
    end
end

%Recalculate Y-axis rotated points in 3d space
rotDepthPointsY = rotDepthPointsX;
rotMatY = [cos(aveRotY) 0 sin(aveRotY); 0 1 0; -sin(aveRotY) 0 cos(aveRotY)];
for b = 1:size(depthPoints,1)
    for c = 1:size(depthPoints,3)
        if c ~= 4
            depthlessCoor = rotDepthPointsX(b,:,c);
            depthlessCoor(3) = depthlessCoor(3) - zDepth;
            rotDepthPointsY(b,:,c) = (rotMatY * depthlessCoor.').' + [0 0 zDepth];
        end
    end
end

undPersImagePoints = rotDepthPointsY;

%Convert rotated 3d camera coordinates into image coordinates
for k = 1:size(depthPoints,1)
    for h = 1:size(depthPoints,3)
        if h ~= 4
            %convert camera coordinates to image coordinates
            undPersImagePoints(k,:,h) = rotDepthPointsY(k,:,h) * ... 
                cameraParams.IntrinsicMatrix;
            %divide by z scale factor to get image points
            undPersImagePoints(k,:,h) = undPersImagePoints(k,:,h)./ ...
                undPersImagePoints(k,3,h);
        end
    end
end

%Concantenate image points to 2d image points array using useful images
origUnd2d = detectCheckerboardPoints(imread(imageFileNames{3}));
persUnd2d = undPersImagePoints(:, 1:2, 3);

%pictures that give best output
b = [5 6 7 8 10 11];


for i = 1:size(b, 2)
    origUnd2d = cat(1,origUnd2d,detectCheckerboardPoints(imread(imageFileNames{b(i)})));
    persUnd2d = cat(1,persUnd2d,undPersImagePoints(:,1:2,b(i)));
end

%Compare undistorted and rotated-undistorted images
figure;
tform = fitgeotrans(origUnd2d(:,:),persUnd2d(:,:),'projective');
[hope, hope_ref] = imwarp(undistortedImage, tform);
X = transformPointsForward(tform, undistortedPoints);
%%
%convert coordinate systems between images
[X_int, Y_int] = worldToIntrinsic(hope_ref, X(:,1), X(:,2));
C = transformPointsForward(tform, testPoints2);
[m, n] = worldToIntrinsic(hope_ref, C(:,1), C(:,2));
imshow(hope)
hold on
plot(X_int, Y_int, 'bo', m, n, 'g*')



%%
% (x, y) index of pixelMap array corresponds to pixel in originalImage
% (x, y, 1) and (x, y, 2) are the corrected x and y coordinates,
% respectively
% pixelMap = zeros(size(originalImage, 2), size(originalImage, 1), 2);
% 
% for i = 1:size(originalImage, 1)
%     for k = 1:size(originalImage, 2)
%         temp = undistortPoints([k i], cameraParams);
%         temp = [temp(:,1) - newOrigin(1), temp(:,2) - newOrigin(2)];
%         temp_trans = transformPointsForward(tform, temp);
%         [x, y] = worldToIntrinsic(hope_ref, temp_trans(1), temp_trans(2));
%         pixelMap(k, i, :) = [x y];
%     end
% end
% 
% save('SA_pixelMap.mat', 'pixelMap');

pixelMap = load('SA_pixelMap.mat');
pixelMap = pixelMap.pixelMap;
size(originalImage)

figure;
subplot(1,2,1);
imshow(originalImage);
hold on
plot(500, 2, 'g*');

subplot(1,2,2);
imshow(hope);
hold on
plot(pixelMap(500, 2, 1), pixelMap(500, 2, 2), 'g*');


